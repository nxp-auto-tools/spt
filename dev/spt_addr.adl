define (arch=spt_addressing) {

  define (instrfield=immed_or_reg_src_fld) {

    bits = 121;
    enumerated = (".immed",("",".reg"));
  }

  define (reg=PC) {
    attrs = (nia,cia);
  }

  define (instrfield=opcode) {
    bits = (127,122);
  }

  define (instrfield=ima_fld) {
    bits = 109;
    enumerated = (".imm",".ind");
    value = ".imm";
  }

  define (instrfield=src_add) {
    bits = (95, 80);
  }

  define (instrfield=dest_add) {
    bits = (79, 64);
  }

  define (instrfield=src2_add) {
    bits = (63, 48);
  }

  define (instrfield=imm_dat) {
    bits = (47,0);
    type = immed;
    is_signed = true;
  }


#define MEM_WR        0
#define MEM_TRAM      1
#define MEM_OPRAM     2
#define MEM_SPR       3
#define MEM_HW_SPR    4
#define MEM_EVT_SPR   5
#define MEM_CHRP_SPR  6
#define MEM_RESERVED  7

#define SLICE_MASK    0x7


  unsigned decode_mem(unsigned addr) {
    if (addr & 0xc000) {
      return (addr & 0x8000) ? MEM_OPRAM : MEM_TRAM;
    }
    else if (addr < 0x1032) {
      if (addr < 0x30) {
        return MEM_WR;
      }
      else if((addr == 0x100c)
        || (addr == 0x100d)) {
        return MEM_SPR;
      }
      else if (((0x1010 <= addr) && (addr <= 0x1012))
        || (addr == 0x1014)
        || (addr == 0x1030)
        || (addr == 0x1031)) {
        return MEM_HW_SPR;
      }
      else if ((0x1016 <= addr) && (addr <= 0x1017)) {
        return MEM_EVT_SPR;
      }
      else if ((0x1020 <= addr) && (addr <= 0x1027)) {
        return MEM_CHRP_SPR;
      }
      return MEM_RESERVED;
    }
  return MEM_RESERVED;
  }

#define DS_BANK_NONE 8
#define DS_COLUMN_NONE 512
#define DS_SLICE_NONE 8

  unsigned decode_bank(unsigned addr) {
	if (addr & 0xc000) {
		return (addr & 0x8000) ? ((addr >> 12) & 0x7) /* OR */ : ((addr >> 12) & 0x1) /* TR */;
	}
	return DS_BANK_NONE; /* WR or SPR, bank is empty */
  }

  unsigned decode_column(unsigned addr) {
	if (addr & 0xc000) { /* OR or TR */
		return ((addr >> 3) & 0x1ff);
	}
	return DS_COLUMN_NONE; /* WR or SPR */
  }

// Used to print either memory or registers in tandem
  unsigned decode_column_or_index(unsigned addr) {
  	if (addr & 0xc000) { /* OR or TR */
		return ((addr >> 3) & 0x1ff);
	}
	if (addr < 0x30) { /* WR */
		return addr;
	}
	unsigned slice = addr & 0x3f;
	if (slice <= 0xd) { /* SPR */
		return slice;
	}
	if (slice <= 0x14) { /* HW_SPR_0-4 */
		return slice - 0x10;
	}
	if (slice <= 0x17) { /* EVT_SPR */
		return slice - 0x16;
	}
	if (slice <= 1027) { /* CHRP_SPR */
		return slice - 0x20; 
	}
	return slice - 0x30 + 6; /* HW_SPR_6-7 */
  }

  unsigned decode_slice(unsigned addr) {
	if (addr & 0xc000) { /* OR or TR */
		return (addr & 0x7);
	}
	/* WR or SPR */
	return (addr & 0x3f);
  }

  unsigned decode_ram_slice(unsigned addr) {
	if (addr & 0xc000) { /* OR or TR */
		return (addr & 0x7);
	}
	return DS_SLICE_NONE;
  }


  std::string get_mem_name(unsigned x) {
    unsigned m = decode_mem(x);
    ostringstream s;
    switch(m) {
      case MEM_WR: s << "WR_" << decode_slice(x); break;
      case MEM_TRAM: s << "TR_" << decode_bank(x) << "_" << decode_column(x) << "_" << decode_slice(x); break;
      case MEM_OPRAM: s << "OR_" << decode_bank(x) << "_" << decode_column(x) << "_" << decode_slice(x); break;
      case MEM_SPR: s << "SPR_" << decode_slice(x); break;
      case MEM_HW_SPR:
        if (x < 0x1030) {
          s << "HW_SPR_" << (decode_slice(x) - 0x10);
        }
        else {
          s << "HW_SPR_" << (decode_slice(x) - 0x30 + 6);
        }
        break;
      case MEM_EVT_SPR: s << "EVT_SPR_" << (decode_slice(x) - 0x16); break;
      case MEM_CHRP_SPR: s << "CHRP_SPR_" << (decode_slice(x) - 0x20); break;
      default: s << "0x" << hex << x << " (reserved)";
    }
    return s.str();
  }


define (instrfield=ds_wr) {
	pseudo = true;
	width = 6;
	enumerated = (
#include "ds_wr.h"
	);
}

define (instrfield=ds_src_ind) {
	pseudo = true;
	width = 16;
	enumerated = (
#include "ds_wr.h"
	);
}


// ds_mem*
define (instrfield=ds_mem) {
	pseudo=true;
	width=3;
	enumerated = ("WR", "TR", "OR", "SPR", "HW_SPR", "EVT_SPR", "CHRP_SPR", "");
}

define (instrfield=ds_mem1) {
	pseudo=true;
	width=3;
	enumerated = ("WR", "TR", "OR", "SPR", "HW_SPR", "EVT_SPR", "CHRP_SPR", "");
}

define (instrfield=ds_mem2) {
	pseudo=true;
	width=3;
	enumerated = ("WR", "TR", "OR", "SPR", "HW_SPR", "EVT_SPR", "CHRP_SPR", "");
}

define (instrfield=ds_mem3) {
	pseudo=true;
	width=3;
	enumerated = ("WR", "TR", "OR", "SPR", "HW_SPR", "EVT_SPR", "CHRP_SPR", "");
}


// ds_bank*
define (instrfield=ds_bank) {
	pseudo=true;
	display=dec; 
	width=3;
}

define (instrfield=ds_bank1) {
	pseudo=true;
	display=dec; 
	width=3;
}

define (instrfield=ds_bank2) {
	pseudo=true;
	display=dec; 
	width=3;
}

// ds_column*
define (instrfield=ds_column) {
	pseudo=true;
	width=9;
	display=dec;
}

define (instrfield=ds_column1) {
	pseudo=true;
	width=9;
	display=dec;
}

define (instrfield=ds_column2) {
	pseudo=true;
	width=9;
	display=dec;
}


// ds_ram_slice
define (instrfield=ds_ram_slice) {
	pseudo=true;
	width=3;
	display=dec;
}

define (instrfield=ds_ram_slice1) {
	pseudo=true;
	width=3;
	display=dec;
}

define (instrfield=ds_ram_slice2) {
	pseudo=true;
	width=3;
	display=dec;
}


// Disassemble RAM addresses as <mem>_<bank>_<column>_<slice> symbols
#define DS_RAM(m)  ds_mem(decode_mem(m)),ds_bank(decode_bank(m)),ds_column(decode_column(m)),ds_ram_slice(decode_ram_slice(m))
#define DS_RAM1(m) ds_mem1(decode_mem(m)),ds_bank1(decode_bank(m)),ds_column1(decode_column(m)),ds_ram_slice1(decode_ram_slice(m))
#define DS_RAM2(m) ds_mem2(decode_mem(m)),ds_bank2(decode_bank(m)),ds_column2(decode_column(m)),ds_ram_slice2(decode_ram_slice(m))


// ds_str_bank*
define (instrfield=ds_str_bank) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_bank1) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_bank2) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_bank3) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}


// ds_str_column*
define (instrfield=ds_str_column2) {
		pseudo=true;
		width=10;
		enumerated = (
#include "ds_column.h"
		, ""
		);
	}


// ds_index_column*
define (instrfield=ds_index_column) {
	pseudo=true;
	width=9;
	display=dec;
}

define (instrfield=ds_index_column1) {
	pseudo=true;
	width=9;
	display=dec;
}

define (instrfield=ds_index_column2) {
	pseudo=true;
	width=9;
	display=dec;
}

define (instrfield=ds_index_column3) {
	pseudo=true;
	width=9;
	display=dec;
}


// ds_str_slice*
define (instrfield=ds_str_slice) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_slice1) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_slice2) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

define (instrfield=ds_str_slice3) {
	pseudo=true;
	width=3;
	enumerated = ("_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "");
}

// Disassemble memory addresses as <mem>_<bank>_<column>_<slice> or <reg>_<index> by using <mem><_bank/"">_<column/index><_slice/"">
#define DS_MEM(m) ds_mem(decode_mem(m)),ds_str_bank(decode_bank(m)),ds_index_column(decode_column_or_index(m)),ds_str_slice(decode_ram_slice(m))
#define DS_MEM1(m) ds_mem1(decode_mem(m)),ds_str_bank1(decode_bank(m)),ds_index_column1(decode_column_or_index(m)),ds_str_slice1(decode_ram_slice(m))
#define DS_MEM2(m) ds_mem2(decode_mem(m)),ds_str_bank2(decode_bank(m)),ds_index_column2(decode_column_or_index(m)),ds_str_slice2(decode_ram_slice(m))
#define DS_MEM3(m) ds_mem3(decode_mem(m)),ds_str_bank3(decode_bank(m)),ds_index_column3(decode_column_or_index(m)),ds_str_slice3(decode_ram_slice(m))

// Disassemble memory addresses as empty or <mem>_<bank>_<column>_<slice> by using <mem/""><_bank/""><_column/""><_slice/"">
#define DS0_MEM2(m) ds_mem2(decode_mem(m)),ds_str_bank2(decode_bank(m)),ds_str_column2(decode_column(m)),ds_str_slice2(decode_ram_slice(m))


  unsigned chk_size(unsigned sz) {
	if (sz > 8192)
		error(0, "illegal vector size: ", sz, ", expected value in range 0-8192");
	if (sz == 0)
		info(0, "when vector size is 0, the maximum value of 8192 operands is assumed");
	return sz;
  }

  unsigned get_mode ( unsigned x ) {
       return x >> 14 ;
  }


// Rules to be used by instruction definitions to check operand restrictions
  define (assembler) {

    // VEC_SZ
    define (rule=R_vec_sz) {
      action = func(InstrInfo ii) {
        if (vec_sz == 0)
          info(0, "when vector size is 0, the maximum value of 8192 operands is assumed.");
        };
    }

    define (rule=R_src_oram_aligned) {
      action = func(InstrInfo ii) {
        unsigned md = decode_mem(src_add);
        if ((md != MEM_OPRAM) || (src_add & SLICE_MASK)) {
          error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                ", expected aligned Operand RAM address (e.g. OR_x_y_0).");
        }
      };
    }

    // DEST_ADD must be an 8-bit aligned OPRAM address
    define (rule=R_dest_oram_aligned) {
      action = func(InstrInfo ii) {
        unsigned md = decode_mem(dest_add);
        if ((md != MEM_OPRAM) || (dest_add & SLICE_MASK)) {
          error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", expected aligned Operand RAM address (e.g. OR_x_y_0).");
        }
      };
    }

    // DEST_ADD must be valid RAM address that is 8-bit aligned
    define (rule=R_dest_ram_aligned) {
      action = func(InstrInfo ii) {
        unsigned m = decode_mem(dest_add);
        if ((m != MEM_OPRAM && m != MEM_TRAM) || (dest_add & SLICE_MASK)) {
            error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", expected aligned Operand RAM or Twiddle RAM (e.g. OR_x_y_0, TR_x_y_0).");
        }
      };
    }

    // DEST_ADD must be a valid unaligned RAM address (used by copy.shift)
    define (rule=R_dest_ram_unaligned) {
      action = func(InstrInfo ii) {
        unsigned m = decode_mem(dest_add);
        if ((m != MEM_OPRAM && m != MEM_TRAM) || (0 == (dest_add & SLICE_MASK))) {
            error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", expected unaligned Operand RAM or Twiddle RAM (e.g. OR_x_y_z, TR_x_y_z, z = 1..7).");
        }
      };
    }

    // SRC_ADD must be valid RAM address that is 8-bit aligned
    define (rule=R_src_ram_aligned) {
      action = func(InstrInfo ii) {
        unsigned m = decode_mem(src_add);
        if ((m != MEM_OPRAM && m != MEM_TRAM) || (src_add & SLICE_MASK)) {
            error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                ", expected aligned Operand RAM or Twiddle RAM (e.g. OR_x_y_0, TR_x_y_0).");
        }
      };
    }

    // SRC_ADD must be an OPRAM or TRAM address
    define (rule=R_src_ram) {
      action = func(InstrInfo ii) {
        unsigned md = decode_mem(src_add);
        if (md != MEM_OPRAM && md != MEM_TRAM) {
          error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                ", expected Operand or Twiddle RAM address (e.g. OR_x_y_z, TR_x_y_z).");
        }
      };
    }

    // SRC_ADD must be valid aligned memory address or a register
    define (rule=R_src_valid_loc) {
      action = func(InstrInfo ii) {
        unsigned loc = decode_mem(src_add);
          if (loc >= MEM_RESERVED) {
            error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                  ", expected a valid address or register.");
          } else if ((loc == MEM_OPRAM || loc == MEM_TRAM)
                    && (src_add & SLICE_MASK)) {
            error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                ", expected aligned Operand RAM or Twiddle RAM (e.g. OR_x_y_0, TR_x_y_0).");
          }
      };
    }

    // SRC_ADD must be work register or SPR
    define (rule=R_src_valid_reg) {
      action = func(InstrInfo ii) {
        unsigned reg = decode_mem(src_add);
        if ((reg >= MEM_RESERVED) || (reg == MEM_TRAM) || (reg == MEM_OPRAM)) {
          error(0, "illegal operand src_add: " + get_mem_name(src_add) +
                ", expected a valid work register or SPR.");
        }
      };
    }

    // DEST_ADD must be a valid aligned memory address, a work register or a writable SPR
    define (rule=R_dest_valid_loc) {
      action = func(InstrInfo ii) {
        unsigned loc = decode_mem(dest_add);
        if (loc >= MEM_RESERVED) {
          error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", expected a valid address or register.");
        } else if ((loc == MEM_OPRAM || loc == MEM_TRAM)
                  && (dest_add & SLICE_MASK)) {
          error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", expected aligned Operand RAM or Twiddle RAM (e.g. OR_x_y_0, TR_x_y_0).");
        } else if (loc == MEM_HW_SPR) {
          error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", read-only SPR is a not a valid destination register.");
        }
     };
   }

   // DEST_ADD must be work register or writable SPR
   define (rule=R_dest_valid_reg) {
     action = func(InstrInfo ii) {
       unsigned reg = decode_mem(dest_add);
       if ((reg >= MEM_RESERVED) || (reg == MEM_TRAM) || (reg == MEM_OPRAM)) {
         error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
               ", expected a valid work register or writable SPR.");
       } else if (reg == MEM_HW_SPR) {
          error(0, "illegal operand dest_add: " + get_mem_name(dest_add) +
                ", read-only SPR is a not a valid destination register.");
       }
     };
   }

   // SRC2_ADD must be work register or SPR
   define (rule=R_src2_valid_reg) {
     action = func(InstrInfo ii) {
       unsigned loc = decode_mem(src2_add);
       if ((loc >= MEM_RESERVED) || (loc == MEM_TRAM) || (loc == MEM_OPRAM)) {
         error(0, "illegal operand src2_add: " + get_mem_name(src2_add) +
               ", expected a valid work register or SPR.");
       }
     };
   }

   // SRC_ADD for IMA = 1 must be a work register
   define (rule=R_src_ind) {
     action = func(InstrInfo ii) {
       unsigned m = decode_mem(src_add);
       if (m != MEM_WR) {
         error(0, "illegal operand src_add for indirect memory access: " + get_mem_name(src_add) +
               ", expected a work register (e.g. WR_x).");
       }
     };
   }

	// SGI_ADD must be TRAM address
	define (rule=R_sgi_tram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(sgi_add);
			if (t != MEM_TRAM) {
				error(0, "illegal operand sgi_add: " + get_mem_name(sgi_add) +
						", expected Twiddle RAM address (e.g. TR_x_y_z).");
			}
		};
	}

	// COPY THLD_ADD must be a work register, an OPRAM or TRAM address
	define (rule=R_thld_wr_ram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(thld_add);
			if (t != MEM_WR && t != MEM_OPRAM && t != MEM_TRAM) {
				error(0, "illegal operand thld_add: " + get_mem_name(thld_add) +
						", expected work register, Operand RAM or Twiddle RAM address (e.g. WR_x, OR_x_y_z, TR_x_y_z).");
			}
		};
	}

	// MAXS THLD_ADD must be a work register or an OPRAM address, MAXS has no access to TRAM
	define (rule=R_thld_wr_opram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(thld_add);
			if (t != MEM_WR && t != MEM_OPRAM) {
				error(0, "illegal operand thld_add: " + get_mem_name(thld_add) +
						", expected work register or Operand RAM address (e.g. WR_x, OR_x_y_z).");
			}
		};
	}

	// GM_ADD must be a work register or an OPRAM address
	define (rule=R_gm_wr_opram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(gm_add);
			if (t != MEM_OPRAM && t != MEM_WR) {
				error(0, "illegal operand gm_add: " + get_mem_name(gm_add) +
						", expected work register or Operand RAM address (e.g. WR_x, OR_x_y_z).");
			}
		};
	}

	// MULT_COEF_ADD must be a work register or a TRAM address
	define (rule=R_mult_coef_wr_tram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(mult_coef_add);
			if (t != MEM_TRAM && t != MEM_WR) {
				error(0, "illegal operand mult_coef_add: " + get_mem_name(mult_coef_add) +
						", expected work register or Twiddle RAM address (e.g. WR_x, TR_x_y_z).");
			}
		};
	}

	// MULT_COEF_ADD must be TRAM address
	define (rule=R_mult_coef_tram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(mult_coef_add);
			if (t != MEM_TRAM) {
				error(0, "illegal operand mult_coef_add: " + get_mem_name(mult_coef_add) +
						", expected Twiddle RAM address (e.g. TR_x_y_z).");
			}
		};
	}

	// TAP_COEF_ADD must be TRAM address
	define (rule=R_tap_coef_tram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(tap_coef_add);
			if (t != MEM_TRAM) {
				error(0, "illegal operand tap_coef_add: " + get_mem_name(tap_coef_add) +
						", expected Twiddle RAM address (e.g. TR_x_y_z).");
			}
		};
	}

	// SCP_COEF_ADD must be TRAM address
	define (rule=R_scp_coef_tram) {
		action = func(InstrInfo ii) {
			unsigned t = decode_mem(scp_coef_add);
			if (t != MEM_TRAM) {
				error(0, "illegal operand scp_coef_add: " + get_mem_name(scp_coef_add) +
						", expected Twiddle RAM address (e.g. TR_x_y_z).");
			}
		};
	}

   // Validate operands for PDMA Instruction.
   define (rule=R_valid_pdma_operands) {
     action = func(InstrInfo ii) {

       if (ii.instrName() == "pdma_ind") { // pdma.ind version
         if (decode_mem(opram_mem_start_addr) != 0) {
           error(0, "illegal operand opram_mem_start_addr: " + get_mem_name(opram_mem_start_addr) +
                  ", expected a valid work register index for PDMA indirect version (e.g. WR_x).");
         }
       } else {
         if (get_mode(opram_mem_start_addr) < 2) {
           error(0, "illegal operand opram_mem_start_addr: " + get_mem_name(opram_mem_start_addr) +
                  ", expected an Operand RAM address (e.g. OR_x_y_0).");
         } else if (opram_mem_start_addr % 8 != 0) {
           error(0, "illegal operand opram_mem_start_addr : 0x" , hex, opram_mem_start_addr,
                 ", OPRAM memory start address should be multiple of 8 for PDMA transfer.");
         }
       }

       if (opram_continuous_addr == 0) {
         error(0, "illegal operand opram_continuous_addr : 0x" , hex, opram_continuous_addr,
               ", OPRAM continuous start address cannot be 0 for PDMA transfer.");
       }

       if (sysram_continous_addr == 0) {
         error(0, "illegal operand sysram_continous_addr : 0x" , hex, sysram_continous_addr,
               ", SRAM continous start address cannot be 0 for PDMA transfer.");
       }

       if (((sysram_continous_addr & (sysram_continous_addr - 1)) != 0)
           && (data_packing == 18 /* .CP4D_FMTB */
               || data_packing == 20 /* .CP8_FMTB */
               || data_packing == 23 /* .CP16_FMTB */
               || data_packing == 29 /* .CP4_FMTB */)) {
         error(0, "illegal operand sysram_continous_addr : 0x" , hex, sysram_continous_addr,
               ", SRAM continous start address must of a power of 2 for the given data packing mode.");
       }

       // OPRAM Continuous Address should be in multiple of 2 for 16-bit Mix Mode.
       if ((data_packing == 6) && (opram_continuous_addr % 2 != 0 )) {
         error(0, "illegal operand opram_continuous_addr : 0x", hex , opram_continuous_addr,
                ", opram_continuous_addr should be multiple of 2 for 16-bit Transpose Mode for PDMA transfer.");
       }

       if (vector_len == 0) {
         error(0, "illegal operand vector_len : 0, vector length cannot be 0 for PDMA transfer.");
       }

       if (trans_type == 0) { // .sysram2opram
         switch (data_packing) {
           case  1 : // .24cmplx
           case  4 : // .48bin
             if (vector_len % 8 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 8 for the given data packing mode.");
             }
             break;

           case  6 : // .16bit_transpose
             if (vector_len % 16 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 16 for the given data packing mode.");
             }
             break;

           case  3 : // .16real
           case 16 : // .CP4D
           case 18 : // .CP4D_FMTB
           case 20 : // .CP8_FMTB
           case 21 : // .CP8_FMTC
           case 22 : // .CP16_FMTA
             if (vector_len % 2 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 2 for the given data packing mode.");
             }
             break;

           case  2 : // .24real
           case  5 : // .16swap
           case 23 : // .CP16_FMTB
           case 24 : // .CP16_FMTC
             if (vector_len % 4 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 4 for the given data packing mode.");
             }
             break;

           case 25 : // .CP16_FMTD
             if (vector_len % 3 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 3 for the given data packing mode.");
             }
             break;

           default : break;
         }
       }

       if (trans_type == 1) { // .opram2sysram
         switch (data_packing) {
           case 6 : // .16bit_transpose
           case 22 : // .CP16_FMTA
           case 23 : // .CP16_FMTB
           case 24 : // .CP16_FMTC
           case 25 : // .CP16_FMTD
           case 28 : // .CP4_FMTA
           case 31 : // .CP16
             if (vector_len % 16 != 0) {
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be a multiple of 16 slices for the given data packing mode.");
             }
             break;

           default :
             if (vector_len % 8 != 0) {
               // multiple of 8 slices for any OPRAM-System memory transfer
               error(0, "illegal operand vector_len : ", vector_len, 
                     ", vector length should be multiple of 8 for OPRAM->SRAM transfer.");
             }
             break;
         }
       }
      };
    }

   // Validate operands for PDMA flex mode instruction SYSRAM to OPRAM.
   define (rule=R_valid_pdma_flex_operands) {
     action = func(InstrInfo ii) {

       if (ii.instrName() == "pdma_flex_ind") { // pdma.ind version
         if (decode_mem(opram_mem_start_addr) != 0) {
           error(0, "illegal operand opram_mem_start_addr: " + get_mem_name(opram_mem_start_addr) +
                  ", expected work register for indirect version (e.g. WR_x).");
         }
       } else {
         if (get_mode(opram_mem_start_addr) < 2) {
           error(0, "illegal operand opram_mem_start_addr: " + get_mem_name(opram_mem_start_addr) +
                  ", expected an Operand RAM address (e.g. OR_x_y_0).");
         } else if (opram_mem_start_addr % 8 != 0) {
           error(0, "illegal operand opram_mem_start_addr : 0x" , hex, opram_mem_start_addr , 
                 " , OPRAM memory start address should be multiple of 8 for PDMA transfer.");
         }
       }

       if (opram_continuous_addr == 0) {
         error(0, "illegal operand opram_continuous_addr : 0x" , hex, opram_continuous_addr , 
               " , OPRAM continuous start address cannot be 0 for PDMA transfer.");
       }

       if (vector_len == 0) {
         error(0, "illegal operand vector_len : 0, vector length cannot be 0 for PDMA transfer.");
       }
       if (vector_len % 8 != 0) {
          error(0, "illegal operand vector_len : ", vector_len, ", expected multiple of 8.");
       }

       if (trans_type == 1) {
         unsigned tmode = get_mode(tram_start_addr);
         if (tmode != MEM_TRAM) {
           error(0, "illegal operand tram_start_addr: " + get_mem_name(tram_start_addr) +
                 ", expected Twiddle RAM address (e.g. TR_x_y_z).");
         }
        }
      };
    }

 }; // end of assembler block for asm_rules

// Identity macro to help with field value transfer in instruction alias definitions
#define ID(X) X(X)


 } // EOF
